<a (click)="handleShowGuide()">{{showGuide ? 'Hide guide' : 'Show guide'}}</a>
<div *ngIf="showGuide">
  <ul>
    <li>
      <em>File offset</em>: expressed in hexadecimal. The bytes are displayed from left to right and top to bottom. The left
      column represents the 7 most significant digits while the top row represents the least significant digit. The cell
      on the third row (00000020) and last column (0F) has a file offset of 0000002F.</li>
    <li>
      <em>Little-endian</em>: Windows is a
      <app-link [href]="'https://en.wikipedia.org/wiki/Endianness'">little-endian</app-link> system. This means than the least significant bytes will appear before the most significant
      ones. So if you were to find the following value: E0 93 01 00, the address would be 00 01 93 E0 - only the byte order
      is inverted, not the order within a byte - which would commonly be written as 0x193E0 (0x denotes a hex notation and
      the leading 0s are dropped as they are not significant).</li>
    <li>
      <em>Relative Virtual Address (RVA)</em>: the address of an item after it is loaded into memory, with the base address of
      the image file subtracted from it.</li>
  </ul>
  <p>If this was not boring enough I recommend a couple of links:</p>
  <ul>
    <li>
      <app-link [href]="'https://www.red-gate.com/simple-talk/blogs/anatomy-of-a-net-assembly-pe-headers/'">Anatomy of a .NET Assembly â€“ PE Headers</app-link> Great blog post</li>
    <li>
      <app-link [href]="'https://msdn.microsoft.com/library/windows/desktop/ms680547(v=vs.85).aspx'">The PE Format specification</app-link> The official specification from Microsoft
    </li>
  </ul>
</div>
<div>
  <input type="file" (change)="fileChanged($event)">
</div>
<span *ngIf="fileName || isReading">{{isReading ? 'Reading' : 'Read'}} "{{fileName}}"</span>
<div class="bytes-container">
  <div *ngIf="pe" class="bytes">
    <span class="offset unit">Offset</span>
    <span class="unit">00</span>
    <span class="unit">01</span>
    <span class="unit">02</span>
    <span class="unit">03</span>
    <span class="unit">04</span>
    <span class="unit">05</span>
    <span class="unit">06</span>
    <span class="unit">07</span>
    <span class="unit">08</span>
    <span class="unit">09</span>
    <span class="unit">0A</span>
    <span class="unit">0B</span>
    <span class="unit">0C</span>
    <span class="unit">0D</span>
    <span class="unit">0E</span>
    <span class="unit">0F</span>
    <ng-template ngFor let-hex [ngForOf]="pe.hexes" let-i="index">
      <span *ngIf="i % 16 === 0" class="offset unit">{{i | byte | leftpad:8 }}</span>
      <span [ngClass]="{
      'dos-header': hex.isDosHeader(),
      'signature-offset': hex.isSignatureOffset(),
      'signature': hex.isSignature(),
      'coff-header': hex.isCoffHeader(),
      'standard-fields': hex.isStandardFields(),
      'magic-number': hex.isMagicNumber(),
      'address-entry-point': hex.isAddressOfEntryPoint(),
      'dos-stub': hex.isDosStub(),
      'nt-specific-fields-headers': hex.isNtSpecificFieldsHeaders(),
      'data-directories': hex.isDataDirectories(),
      'import-table-directory-size': hex.isImportTableDirectorySize(),
      'import-table-directory-rva': hex.isImportTableDirectoryRva(),
      'import-address-table-directory-size': hex.isImportAddressTableDirectorySize(),
      'import-address-table-directory-rva': hex.isImportAddressTableDirectoryRva(),
      'cli-header-directory-size': hex.isCliHeaderDirectorySize(),
      'cli-header-directory-rva': hex.isCliHeaderDirectoryRva(),
      'text-section-header': hex.isTextSectionHeader(),
      'rsrc-section-header': hex.isRsrcSectionHeader(),
      'reloc-section-header': hex.isRelocSectionHeader(),
      'text-base-rva': hex.isTextBaseRva(),
      'text-file-offset': hex.isTextFileOffset(),
      'rsrc-base-rva': hex.isRsrcBaseRva(),
      'rsrc-file-offset': hex.isRsrcFileOffset(),
      'reloc-base-rva': hex.isRelocBaseRva(),
      'reloc-file-offset': hex.isRelocFileOffset(),
      'cli-header': hex.isCliHeader()
    }">{{hex.value | byte | leftpad:2 }}</span>
    </ng-template>
  </div>
  <div *ngIf="pe" class="bytes-legend">
    <div class="part">
      <p>
        <span class="dos-header">DOS header ({{peConstants.dosHeaderSizeDec}} bytes)</span>
      </p>
      <p>From 00000000 to 0000003F</p>
      <p>We don't really care about this one except for the
        <span class="dos-header signature-offset">signature offset</span> ({{peConstants.signatureOffsetSizeDec}} bytes) which value is
        <span class="dos-header signature-offset">{{pe.signatureOffset.fileOffset | byte | leftpad:8}}</span>.</p>
      <p>We ignore the
        <span class="dos-stub">DOS stub</span> and go to the signature.</p>
    </div>
    <div class="part">
      <p>
        <span class="signature">Signature ({{peConstants.signatureSizeDec}} bytes)</span>
      </p>
      <p>From
        <span class="dos-header signature-offset">{{pe.signature.startOffsetDec | byte | leftpad:8 }}</span> to {{pe.signature.endOffsetDec | byte | leftpad:8 }}</p>
      <p>We couldn't care less about the signature because it's always the same. It's only use is to mark the beginning of the
        sections we're interested in. The signature is directly followed by the
        <span class="coff-header">COFF header / PE file header ({{peConstants.coffHeaderSizeDec}} bytes)</span> which we skip to go to the standard
        fields.
      </p>
    </div>
    <div class="part">
      <p>
        <span class="standard-fields">PE standard fields ({{pe.standardFields.sizeDec}} bytes)</span>
      </p>
      <p>From {{pe.standardFields.startOffsetDec | byte | leftpad:8}} to {{pe.standardFields.endOffsetDec | byte | leftpad:8}}</p>
      <p>It contains the
        <span class="standard-fields magic-number">magic number</span> (the first {{peConstants.magicNumberSizeDec}} bytes) which value is {{pe.magicNumber.hexValue
        | hex}}. The magic number encodes the bitness of the binary, 0x10B is 32-bit (PE32 format) and 0x20B is 64-bit (PE32+
        format). Here we are dealing with a {{pe.is64Bit ? '64' : '32'}}-bit binary.</p>
      <p>For PE32, the size of the standard fields is {{peConstants.standardFieldsPE32SizeDec}} bytes; for PE32+ it is {{peConstants.standardFieldsPE32PlusSizeDec}}
        bytes.
      </p>
      <p>The
        <span class="standard-fields address-entry-point">address of entry point</span> ({{peConstants.addressOfEntryPointSizeDec}} bytes) is located at offset {{peConstants.addressOfEntryPointSubOffsetDec}}
        of the standard fields and has a value of
        <span class="standard-fields address-entry-point">{{pe.addressOfEntryPoint.rva | hex}}</span>. We skip over the
        <span class="nt-specific-fields-headers">NT specific fields header ({{pe.ntSpecificFields.sizeDec}} bytes)</span>. For PE32, the size of the NT specific fields
        header is {{peConstants.ntSpecificFieldsPE32SizeDec}} bytes; for PE32+ it is {{peConstants.ntSpecificFieldsPE32PlusSizeDec}}
        bytes.
      </p>
    </div>
    <div class="part">
      <p>
        <span class="data-directories">Data directories ({{peConstants.dataDirectoriesSizeDec}} bytes)</span>
      </p>
      <p>From {{pe.dataDirectories.startOffsetDec | byte | leftpad:8}} to {{pe.dataDirectories.endOffsetDec | byte | leftpad:8}}</p>
      <ul>
        <li>
          Import table:
          <span class="data-directories import-table-directory-size mono-font">{{pe.importTableDirectory.size.hexValue | hex}}</span>
          bytes located at base RVA
          <span class="data-directories import-table-directory-rva mono-font">{{pe.importTableDirectory.rva.rva | hex}}</span>
        </li>
        <li>
          Import address table:
          <span class="data-directories import-address-table-directory-size mono-font">{{pe.importAddressTableDirectory.size.hexValue | hex}}</span>
          bytes located at base RVA
          <span class="data-directories import-address-table-directory-rva mono-font">{{pe.importAddressTableDirectory.rva.rva | hex}}</span>
        </li>
        <li>
          CLI header:
          <span class="data-directories cli-header-directory-size mono-font">{{pe.cliHeaderDirectory.size.hexValue | hex}}</span>
          bytes located at base RVA
          <span class="data-directories cli-header-directory-rva mono-font">{{pe.cliHeaderDirectory.rva.rva | hex}}</span>
        </li>
      </ul>
    </div>
    <div *ngIf="pe.isManaged" class="part">
      <ul>
        <li>
          <span class="text-section-header">Text section header ({{peConstants.sectionHeaderSize}} bytes)</span>
          : pointing to base RVA
          <span class="text-section-header text-base-rva mono-font">{{pe.textSectionItem.baseRva.rva | hex}}</span>
          , file offset
          <span class="text-section-header text-file-offset mono-font">{{pe.textSectionItem.fileOffset.fileOffset | hex}}</span>
        </li>
        <li>
          <span class="rsrc-section-header">Rsrc section header ({{peConstants.sectionHeaderSize}} bytes)</span>
          : pointing to base RVA
          <span class="rsrc-section-header rsrc-base-rva mono-font">{{pe.rsrcSectionItem.baseRva.rva | hex}}</span>
          , file offset
          <span class="rsrc-section-header rsrc-file-offset mono-font">{{pe.rsrcSectionItem.fileOffset.fileOffset | hex}}</span>
        </li>
        <li>
          <span class="reloc-section-header">Reloc section header ({{peConstants.sectionHeaderSize}} bytes)</span>
          : pointing to base RVA
          <span class="reloc-section-header reloc-base-rva mono-font">{{pe.relocSectionItem.baseRva.rva | hex}}</span>
          , file offset
          <span class="reloc-section-header reloc-file-offset mono-font">{{pe.relocSectionItem.fileOffset.fileOffset | hex}}</span>
        </li>
      </ul>
    </div>
    <div *ngIf="pe.isManaged" class="part">
      <p>
        <span class="cli-header">CLI header ({{pe.cliHeaderSize}} bytes)</span>
      </p>
      <p>From {{pe.cliHeader.startOffsetDec | byte | leftpad:8}} to {{pe.cliHeader.endOffsetDec | byte | leftpad:8}}</p>
    </div>
    <div *ngIf="!pe.isManaged" class="part">
      <p>
        <span class="cli-header">CLI header ({{pe.cliHeaderSize}} bytes)</span>
      </p>
      <p>This is a native binary, there is no CLI header.</p>
    </div>
  </div>
</div>
<div>
  <p>I will not collect data in any way:</p>
  <ul>
    <li>No ads</li>
    <li>No analytics</li>
    <li>No telemetry</li>
  </ul>
  <p>Azure will collect your IP address when you visit this page.</p>
  <p>I'm using third-party libraries, be mindful of the HTTP requests they initiate if any.</p>
  <p>If you don't want to use the hosted version you can
    <app-link [href]="'https://github.com/gabrielweyer/pe-clr-viewer#running-locally'">run it on your machine instead</app-link>
</div>
<div>Build {{build}} commit
  <app-link [href]="'https://github.com/gabrielweyer/pe-clr-viewer/commit/' + commit">{{commit}}</app-link>, source on
  <app-link [href]="'https://github.com/gabrielweyer/pe-clr-viewer'">GitHub</app-link>, deployed by
  <app-link [href]="'https://www.visualstudio.com/team-services/'">VSTS</app-link>, hosted on
  <app-link [href]="'https://azure.microsoft.com/en-gb/services/storage/blobs/'">Azure Blob storage</app-link>, made by
  <app-link [href]="'https://gabrielweyer.github.io/'">Gabriel Weyer</app-link> with love.</div>
